# 精度计算统一使用说明

## 概述

为了解决 JavaScript 浮点数计算精度问题，项目中所有涉及数值计算的地方都已统一使用 `precisionCalculate` 精度计算工具。

## 问题背景

JavaScript 中的浮点数计算存在精度问题，例如：
```javascript
0.1 + 0.2 = 0.30000000000000004  // ❌ 不准确
0.1 * 3 = 0.30000000000000004    // ❌ 不准确
```

这在财务系统中是不可接受的，因此需要使用精度计算工具。

## 精度计算工具

### 前端工具 (`frontend/src/utils/precision.js`)

```javascript
export const precisionCalculate = {
  // 加法
  add(...numbers) {
    return parseFloat(numbers.reduce((sum, num) => sum + (num || 0), 0).toFixed(2))
  },
  
  // 减法
  subtract(minuend, ...subtrahends) {
    const result = subtrahends.reduce((diff, num) => diff - (num || 0), minuend || 0)
    return parseFloat(result.toFixed(2))
  },
  
  // 乘法
  multiply(...numbers) {
    return parseFloat(numbers.reduce((product, num) => product * (num || 0), 1).toFixed(2))
  },
  
  // 除法
  divide(dividend, divisor) {
    if (!divisor) return 0
    return parseFloat((dividend / divisor).toFixed(2))
  }
}
```

### 后端工具 (`backend/utils/precision.js`)

```javascript
const precisionCalculate = {
  // 加法
  add(...numbers) {
    return parseFloat(numbers.reduce((sum, num) => sum + (num || 0), 0).toFixed(2))
  },
  
  // 减法
  subtract(minuend, ...subtrahends) {
    const result = subtrahends.reduce((diff, num) => diff - (num || 0), minuend || 0)
    return parseFloat(result.toFixed(2))
  },
  
  // 乘法
  multiply(...numbers) {
    return parseFloat(numbers.reduce((product, num) => product * (num || 0), 1).toFixed(2))
  },
  
  // 除法
  divide(dividend, divisor) {
    if (!divisor) return 0
    return parseFloat((dividend / divisor).toFixed(2))
  },

  // 百分比计算
  percentage(value, total) {
    if (!total) return 0
    return parseFloat(((value / total) * 100).toFixed(2))
  },

  // 四舍五入到指定小数位
  round(number, decimals = 2) {
    return parseFloat(Number(number).toFixed(decimals))
  }
}
```

## 已修改的文件

### 后端模型 (Models)

#### 1. Product.js - 产品模型
```javascript
// 修改前
this.dailyTotalProfit = (this.dailyPaymentAmount || 0) -
    ((this.dailySalesVolume || 0) * (this.unitPrice || 0)) -
    (this.shippingCost || 0) - 
    (this.dailyConsumedAmount || 0) -
    (this.handlingFee || 0);

// 修改后
const productCost = precisionCalculate.multiply(
    this.dailySalesVolume || 0, 
    this.unitPrice || 0
);

this.dailyTotalProfit = precisionCalculate.subtract(
    this.dailyPaymentAmount || 0,
    productCost,
    this.shippingCost || 0,
    this.dailyConsumedAmount || 0,
    this.handlingFee || 0,
    this.afterSalesAmount || 0,
    this.afterSalesCost || 0
);
```

#### 2. ProductBudget.js - 产品预算模型
```javascript
// 修改前
this.grossMargin = (this.sellingPrice || 0) -
    (this.unitCost || 0) -
    (this.shippingCost || 0) -
    (this.platformFee || 0) -
    (this.handlingFee || 0);

this.actualCommission = (this.grossMargin / (this.sellingPrice || 0)) * 100;

// 修改后
this.grossMargin = precisionCalculate.subtract(
    this.sellingPrice || 0,
    this.unitCost || 0,
    this.shippingCost || 0,
    this.platformFee || 0,
    this.handlingFee || 0
);

this.actualCommission = precisionCalculate.percentage(
    this.grossMargin,
    this.sellingPrice || 0
);
```

#### 3. CommissionAccounting.js - 佣金核算模型
```javascript
// 修改前
this.commissionProfit = (this.netTransactionData || 0) * (this.commission || 0) / 100;
this.netProfit = this.commissionProfit - (this.dailyConsumption || 0);

// 修改后
this.commissionProfit = precisionCalculate.multiply(
    this.netTransactionData || 0,
    precisionCalculate.divide(this.commission || 0, 100)
);

this.netProfit = precisionCalculate.subtract(
    this.commissionProfit,
    this.dailyConsumption || 0
);
```

#### 4. AccountRecord.js - 账户记录模型
```javascript
// 修改前
isConsistent: Math.abs(recordedBalance - actualBalance) < 0.01,
difference: actualBalance - recordedBalance

// 修改后
isConsistent: Math.abs(precisionCalculate.subtract(recordedBalance, actualBalance)) < 0.01,
difference: precisionCalculate.subtract(actualBalance, recordedBalance)
```

### 后端控制器 (Controllers)

#### 1. productController.js
```javascript
// 修改前
const dailyTotalProfit = (dailyPaymentAmount || 0) - 
  (dailyConsumedAmount || 0) - 
  (handlingFee || 0) - 
  (afterSalesAmount || 0) - 
  (afterSalesCost || 0);

// 修改后
const productCost = precisionCalculate.multiply(
  dailySalesVolume || 0, 
  unitPrice || 0
);

const dailyTotalProfit = precisionCalculate.subtract(
  dailyPaymentAmount || 0,
  productCost,
  shippingCost || 0,
  dailyConsumedAmount || 0,
  handlingFee || 0,
  afterSalesAmount || 0,
  afterSalesCost || 0
);
```

#### 2. financeController.js
```javascript
// 修改前
const netProfit = totalIncome - totalExpense;

// 修改后
const netProfit = precisionCalculate.subtract(totalIncome, totalExpense);
```

#### 3. teamAccountController.js
```javascript
// 修改前
monthlyIncome += Math.abs(stat.totalAmount);
monthlyExpense += Math.abs(stat.totalAmount);

// 修改后
monthlyIncome = precisionCalculate.add(monthlyIncome, Math.abs(stat.totalAmount));
monthlyExpense = precisionCalculate.add(monthlyExpense, Math.abs(stat.totalAmount));
```

### 前端 Store

#### 1. budget.js - 预算 Store
```javascript
// 修改前
const grossMargin = sellingPrice - unitCost - shippingCost - platformFee - handlingFee
const actualCommission = (grossMargin / sellingPrice) * 100

// 修改后
const grossMargin = precisionCalculate.subtract(
  sellingPrice,
  unitCost,
  shippingCost,
  platformFee,
  handlingFee
)

const actualCommission = precisionCalculate.percentage(grossMargin, sellingPrice)
```

#### 2. commissionAccounting.js - 佣金核算 Store
```javascript
// 修改前
const commissionProfit = netTransactionData * commission / 100
const netProfit = commissionProfit - dailyConsumption

// 修改后
const commissionProfit = precisionCalculate.multiply(
  netTransactionData,
  precisionCalculate.divide(commission, 100)
)

const netProfit = precisionCalculate.subtract(commissionProfit, dailyConsumption)
```

### 前端组件

#### ProductList.vue - 产品列表
已经在使用 `precisionCalculate`：
```javascript
// 产品成本计算
productForm.productCost = precisionCalculate.multiply(
  productForm.dailySalesVolume || 0, 
  productForm.unitPrice || 0
)

// 当天总盈亏计算
dailyTotalProfit.value = precisionCalculate.subtract(
  productForm.dailyPaymentAmount || 0,
  productForm.productCost || 0,
  productForm.shippingCost || 0,
  productForm.dailyConsumedAmount || 0,
  productForm.handlingFee || 0,
  productForm.afterSalesCost || 0,
  productForm.afterSalesAmount || 0
)
```

## 使用规范

### 1. 基本运算

```javascript
// ✅ 正确使用
const sum = precisionCalculate.add(10.1, 20.2, 30.3)
const difference = precisionCalculate.subtract(100, 10.5, 5.3)
const product = precisionCalculate.multiply(10.5, 2.3)
const quotient = precisionCalculate.divide(100, 3)

// ❌ 错误使用
const sum = 10.1 + 20.2 + 30.3
const difference = 100 - 10.5 - 5.3
const product = 10.5 * 2.3
const quotient = 100 / 3
```

### 2. 百分比计算

```javascript
// ✅ 正确使用
const percentage = precisionCalculate.percentage(25, 100) // 25%

// ❌ 错误使用
const percentage = (25 / 100) * 100
```

### 3. 四舍五入

```javascript
// ✅ 正确使用
const rounded = precisionCalculate.round(10.567, 2) // 10.57

// ❌ 错误使用
const rounded = parseFloat(10.567.toFixed(2))
```

## 注意事项

1. **所有金额计算必须使用精度计算工具**
2. **统计汇总时也要使用精度计算**
3. **比较金额时考虑精度误差**
4. **前后端保持一致的计算逻辑**

## 测试验证

### 1. 单元测试
```javascript
// 测试精度计算
console.assert(precisionCalculate.add(0.1, 0.2) === 0.3)
console.assert(precisionCalculate.multiply(0.1, 3) === 0.3)
console.assert(precisionCalculate.percentage(25, 100) === 25)
```

### 2. 业务测试
- 产品盈亏计算准确性
- 预算毛利计算准确性
- 佣金核算计算准确性
- 财务统计数据准确性

## 总结

通过统一使用 `precisionCalculate` 精度计算工具，项目中的所有数值计算都能保证精度准确性，避免了 JavaScript 浮点数计算的精度问题。这对于财务管理系统来说是至关重要的。

所有开发人员在进行数值计算时，都应该使用这个工具，确保计算结果的准确性和一致性。
